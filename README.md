# Go
P1022 本题所要求解的是一元一次方程，因为首先确保了一元一次方程一定有解，所以不用判断该方程是否成立，又因为一元一次方程无论什么形式，最后一定会化成kx+b=0这样的形式，所以在处理一元一次方程的时候，要把方程右边的全部移到方程左边来计算，这就需要对右边整体符号进行更改，设一个正负系数f  一个等于号系数equal  x的系数k 储存加减号和未知数前面数字的变量 num 通过遍历获取字符串中每一个字符，当遇到数字的时候，改变num，一直到读到符号或者未知数为止，当遇到数字后面跟的为加号时，常数b就会加上这些数，若遇到数字后面跟的为减号的时候，常数b依旧会加上符号前面的数，但在后面初始化的时候，正负系数f会从1变为-1，当遇到等于号时，因为要把右边的数全部移到左边，所以后续读到的常数或是未知数系数，都要乘上-1，当遇到带有系数的未知数的时候，需要特判一下，因为若是x或者-x，因为未知数前面没有数字，所以会默认为0，显然是不正确的，因此要特判x前面是否有数字，若有的话，则x的系数k乘上num乘上equal乘上f，若是未知数前面没有数字，则直接乘上equal乘上f，（要注意上述所有的操作，在最后都要将num初始化为0）在读入最后一项的时候，若是常数，直接让b加上num，若是未知数的话，则num为0，没有影响，最后计算x的值，也就是－b/k 


P1914 本题很简单，只需要注意循环的问题，若n超过26，则用n减去26，先通过把uint8转化为int类型加上移动的位数n，与122作比较，若小于它，则直接将之转化为string类型输出，若大于它，则用这个数减去122后再加上96，再转化为string类型输出即可

P2404 本题采用dfs的思路和方法，因为1~8都最初可以由若干个1相加而成，所以先设定一个数组，将数组中的元素全部初始化为1，然后采用深度优先搜索，通过不断的拆分回溯，找到满足条件的情况，并按照字典序的大小输出

P1443
